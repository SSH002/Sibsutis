Латентность - количество тактовых циклов, необходимых варпу для исполнения текущей инструкции. Латентность арифметической операции составляет ~10-20, латентность доступа к глобальной памяти составляет ~100-400, в зависимости от архитектуры устройства. Пример: согласно документации Nvidia, типичная латентность для CC 3.x составляет около 11, что означает, что для скрытия латентности необходимо 44 варпа.

32-х битные арифметические инструкции с целыми числами и числами с плавающей точкой и логические операции выполняются на ALU.
64-х битные инструкции выполняются на DP units
Операции с глобальной/разделяемой/локальной памятью выполняются на LSDT units.
Тригонометрические функции исполняются на SPU.

Когда запускается ядро, размер блока и размер сетки определяются конфигурацией функции-ядра. Размер общей памяти для блока определяется кодом ядра. Размер памяти для потока определяется кодом ядра. Распределитель вычислительных заданий (Compute Work Distributor) будет назначать блоки SM, до тех пор пока SM имеет достаточные ресурсы для каждого
блока: общая память, регистры и варпы.
Каждый блок назначен одному SM и выполняется только на нем. Неназначенные блоки будут ждать, пока один из исполняемых блоков не прекратит выполнение и не освободит ресурсы.
Когда выполнение блока прекращается, менеджер ресурсов освобождает его ресурсы.
Когда блок назначен SM, все его варпы становятся активными, т.е. выделяются регистры и варпы добавляются в планировщик варпов.
В каждом тактовом цикле каждый планировщик варпов выбирает один варп из допустимых варпов (Selected Warp) и выдает ему следующие одну или две инструкции. При этом может быть расхождение между количеством запланированных инструкций и выполненных инструкций из-за расхождение адресов (непоследовательный доступ к глобальной памяти, дивергенция
варпов) и конфликты банков при операциях с памятью, инструкций, которые могут быть исполнены только половиной варпа за цикл и, следовательно, должны исполняться дважды (например, инструкции с плавающей точкой).

В каждый момент выдачи инструкций каждый планировщик варпов планирует одну инструкцию для одного из назначенных ему варпов, ожидающему инструкции (если таковые имеются) с помощью политики приоритезированного планирования:

	Loosely-Round-Robin (LRR)
	Greedy-then-oldest (GTO)
	prefetch-Aware
	memory-aware

Наиболее распространенная причина, по которой варп не готов выполнить свою следующую инструкцию, заключается в том, что входные операнды инструкции еще не доступны.
Другая причина в ожидании точки синхронизации. SM полностью используется, когда у всех планировщиков варпов всегда есть какая-либо инструкция, чтобы выдать некоторому варпу на каждом такте. Таким образом латентность полностью скрывается.

Eligible Warp (варп, готовый к исполнению) - следующая инструкция извлечена, и все ее аргументы готовы, ресурсы готовы: ядра fp32 / ядра fp64 / ldstunit / специальные функциональные блоки Stalled Warp (варп, который не готов к выполнению следующей инструкции). Причины:
        Pipeline Busy - вычислительные ресурсы, требуемые инструкцией, еще не доступны
        Instruction Fetch - следующая инструкция еще не получена
        Memory Throttle - большое количество ожидающих операций с памятью препятствует дальнейшему исполнению инструкций
        Memory Dependency - блоки LD / ST недоступны
        Execution Dependency - данные, требуемые инструкцией, еще не доступны
        Synchronization - варп заблокирован _syncthreads().


Активный варп (Active warp) - варп определяется как активный, когда он назначается планировщику варпов, и его потоки начинают выполняться до тех пор, пока они все не завершат работу. Допустимый варп (Selected warp) - варп выбранный для выполнения следующей инструкции в текущем планировщике варпов. Количество выбранных варпов в любом цикле в SM <= количество планировщиков варпов в SM. Дивергенция варпов - нити варпа, исполняющие разные ветки условного оператора, сериализуются.

Заполняемость: отношение среднего количества активных варпов на SM к максимальному количеству активных варпов, поддерживаемых SM
Теоретическая заполняемость - максимальная доступная заполняемость, зависимая от конфигурации выполнения ядра, ресурсах, требуемых ядром, и возможностях устройства CUDA.
Достигнутая заполняемость - средняя заполняемость, измеренная во время выполнения ядра

Теоретическая заполняемость (для указанной СС) контролируется тремя факторами:
Размер блока
Размер общей памяти (на блок)
Размер регистров (на поток)
Более высокая заполняемость не всегда означает более высокую производительность.

Пример:
Compute Capability 5.0
Макс. варпов на мультипроцессор 64
Максимальное количество блоков на мультипроцессор 32
Регистры на мультипроцессор 65536
Разделяемая память на мультипроцессор (байт) 65536

Предположим, размер блока был выбран следующим: 128 нитей (= 4 варпа)
Максимальное количество блоков ограничено размером блока = 64/4 = 16 блоков на SM
Разделяемая память на блок = 5000 байт
Макс. Количество блоков ограничено общей памятью = 65536/5000 = 13,1 ~ 13 блоков
Регистров на нить = 48; на блок = 128 * 48 = 6144; максимальное количество блоков ограничено количеством регистров = 65536/6144 = 10,67 ~ 10 (ограничивающий параметр!)
Таким образом, теоретическая заполняемость составляет 10 * 4/64 = 40/64 = 0,625

Достигнутая заполняемость не может превышать теоретическую заполняемость, поэтому первым шагом к её увеличению должно быть увеличение теоретической заполняемости путем корректировки ограничивающих факторов. Следующим шагом является проверка, близка ли достигнутая величина к теоретической. Достигнутое значение будет ниже
теоретического значения, если теоретическое количество активных варпов не поддерживается в течение всего времени, в течение которого SM активен. Это происходит в следующих ситуациях:
    Несбалансированная нагрузка внутри блоков. Если варпы внутри блока не все выполняются в течение одного и того же времени, рабочая нагрузка считается несбалансированной. Это означает, что в конце ядра меньше активных варпов, что является проблемой, известной как «эффект хвоста».
    Несбалансированная нагрузка на блоки. Если блоки в сетке не все выполняются в течение одного и того же времени. Решением проблемы может стать записк большего числа блоков.
    Слишком мало блоков запущено. Верхний предел для активных блоков на SM определяется теоретической заполняемостью, но этот расчет не учитывает запуск с меньшим количеством блоков на SM. Количество SM на устройстве, умноженное на максимальное количество активных блоков на SM, называется «полной волной», а запуск меньше полной волны приводит к низкой достигнутой заполняемости. Например, на устройстве с 15 SM и конфигурации, предполагающей 100% теоретическую заполняемость с 4 блоками на SM, полная волна будет составлять 60 блоков. Запуск только 45 блоков (при условии сбалансированной рабочей нагрузки) приведет к примерно 75% достигнутой заполняемости.
    Частичная последняя волна. SM имеет максимальное количество варпов, которые могут быть активны одновременно. Поскольку заполняемость - это отношение активных варпов к максимально поддерживаемым активным варпам, степень занятости составляет 100%, если количество активных варпов равно максимальному. Если этот фактор ограничивает активные блоки, заполняемость не может быть увеличена. Например, на графическом процессоре, который поддерживает 64 активных варпа на SM, 8 активных блоков с 256 потоками на блок (8 варпов на блок) обеспечивают 64 активных варпа и 100% теоретическую заполняемость. Аналогично, 16 активных блоков со 128 потоками на блок (4 варпа на блок) также приводят к 64 активным варпам и 100% теоретической заполняемости.

Задание:
1. Какой будет теоретическая заполняемость для конфигурации из примера, если потребуется 10000 байт разделяемой памяти?
2. Исследовать достигнутую заполняемость для алгоритмов из предыдущей лабораторной работы. Выявить и устранить ограничивающие факторы достигнутой заполняемости.
Произвести измерение производительности до оптимизаций и после.
3. Исследовать зависимость теоретической и достигнутой заполняемости для алгоритмов из предыдущей лабораторной работы от количества нитей в блоке.
4. Построить графики зависимости достигнутой заполняемости от количества нитей в блоке, производительности вычислений от достигнутой заполняемости.

Полезные метрики nvprof:
achieved_occupancy - достигнутая заполняемость
inst_executed - количество выполненных инструкций
inst_issued - количество запланированных инструкций
inst_per_warp - количество выполненных инструкций на один варп
ipc - количество выполненных инструкций на один такт
branch_efficiency - отношение количества инструкций перехода, не приводящих к дивергенции варпов, к общему количеству инструкций перехода
sm_efficiency - эффективность использования мультипроцессоров. Отношение времени, когда на всех мультипроцессорах выполняется по крайней мере один варп, к общему времени выполнения алгоритма.

Ссылки:
Остальные метрики nvprof https://docs.nvidia.com/cuda/profiler-users-guide/index.html#metrics-reference-7x
Описание функции получения информации о GPU cudaGetDeviceProperties -  https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g1bf9d625a931d657e08db2b4391170f0
Online occupancy calculator - https://xmartlabs.github.io/cuda-calculator/
XLS occupancy calculator - https://docs.nvidia.com/cuda/cuda-occupancy-calculator/index.html

Контрольные вопросы:
1. Архитектура GPU.
2. Отличие архитектуры GPU от архитектуры CPU
3. Программная модель CUDA
4. Иерархия памяти GPU
5. Глобальная память GPU. Шаблон использования, оптимизация доступа, метрики производительности работы с глобальной памятью (в т.ч. метрики профилировщика)
6. Разделяемая память GPU. Шаблон использования, оптимизация доступа, метрики производительности работы с разделяемой памятью (в т.ч. метрики профилировщика)
7. Теоретическая и достигнутая заполняемость. Ограничивающие заполняемость факторы.
